x-kafka-common: &kafka-common
  image: apache/kafka:latest
  restart: unless-stopped
  networks:
    - jrmarcco_net
  healthcheck:
    test: ["CMD-SHELL", "ps aux | grep -q 'kafka.Kafka' && test -f /var/lib/kafka/data/meta.properties || exit 1"]
    interval: 30s
    timeout: 10s
    retries: 5
  environment: &kafka-common-env
    # 集群配置
    CLUSTER_ID: ${KAFKA_CLUSTER_ID}
    KAFKA_PROCESS_ROLES: broker,controller
    KAFKA_CONTROLLER_QUORUM_VOTERS: 1@kafka-1:9094,2@kafka-2:9094,3@kafka-3:9094

    # 通信配置
    KAFKA_CONTROLLER_LISTENER_NAMES: CONTROLLER
    KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL
    KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: CONTROLLER:SASL_SSL,INTERNAL:SASL_SSL,EXTERNAL:SASL_SSL

    # SASL 配置 ( OAuth2 )
    KAFKA_SASL_ENABLED_MECHANISMS: OAUTHBEARER
    KAFKA_SASL_MECHANISM_CONTROLLER_PROTOCOL: OAUTHBEARER
    KAFKA_SASL_MECHANISM_INTER_BROKER_PROTOCOL: OAUTHBEARER

    # Controller Quorum 超时配置 ( 避免选举冲突和频繁变更 )
    KAFKA_CONTROLLER_QUORUM_ELECTION_TIMEOUT_MS: 10000
    KAFKA_CONTROLLER_QUORUM_ELECTION_BACKOFF_MAX_MS: 5000
    KAFKA_CONTROLLER_QUORUM_FETCH_TIMEOUT_MS: 5000
    KAFKA_CONTROLLER_QUORUM_REQUEST_TIMEOUT_MS: 5000

    # OAuth2 允许的 URL ( Kafka 3.x 安全限制 )
    KAFKA_OPTS: -Dorg.apache.kafka.sasl.oauthbearer.allowed.urls=${KC_URL}/realms/kafka/protocol/openid-connect/certs,${KC_URL}/realms/kafka/protocol/openid-connect/token

    # OAuth2 回调处理器配置
    KAFKA_LISTENER_NAME_CONTROLLER_OAUTHBEARER_SASL_SERVER_CALLBACK_HANDLER_CLASS: org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallbackHandler
    KAFKA_LISTENER_NAME_CONTROLLER_OAUTHBEARER_SASL_LOGIN_CALLBACK_HANDLER_CLASS: org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginCallbackHandler
    KAFKA_LISTENER_NAME_INTERNAL_OAUTHBEARER_SASL_SERVER_CALLBACK_HANDLER_CLASS: org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallbackHandler
    KAFKA_LISTENER_NAME_INTERNAL_OAUTHBEARER_SASL_LOGIN_CALLBACK_HANDLER_CLASS: org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginCallbackHandler
    KAFKA_LISTENER_NAME_EXTERNAL_OAUTHBEARER_SASL_SERVER_CALLBACK_HANDLER_CLASS: org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallbackHandler
    KAFKA_LISTENER_NAME_EXTERNAL_OAUTHBEARER_SASL_LOGIN_CALLBACK_HANDLER_CLASS: org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginCallbackHandler

    # OAuth2 JWKS Endpoint 配置 ( Controller 监听器 )
    KAFKA_LISTENER_NAME_CONTROLLER_OAUTHBEARER_SASL_JAAS_CONFIG: >-
      org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required
      clientId="${CONTROLLER_CLIENT_ID}"
      clientSecret="${CONTROLLER_CLIENT_SECRET}";
    KAFKA_LISTENER_NAME_CONTROLLER_OAUTHBEARER_SASL_OAUTHBEARER_JWKS_ENDPOINT_URL: ${KC_URL}/realms/kafka/protocol/openid-connect/certs
    KAFKA_LISTENER_NAME_CONTROLLER_OAUTHBEARER_SASL_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${KC_URL}/realms/kafka/protocol/openid-connect/token
    KAFKA_LISTENER_NAME_CONTROLLER_OAUTHBEARER_SASL_OAUTHBEARER_EXPECTED_ISSUER: ${KC_URL}/realms/kafka
    KAFKA_LISTENER_NAME_CONTROLLER_OAUTHBEARER_SASL_OAUTHBEARER_EXPECTED_AUDIENCE: account

    # OAuth2 JWKS Endpoint 配置 ( Internal 监听器 )
    KAFKA_LISTENER_NAME_INTERNAL_OAUTHBEARER_SASL_JAAS_CONFIG: >-
      org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required
      clientId="${BROKER_CLIENT_ID}"
      clientSecret="${BROKER_CLIENT_SECRET}";
    KAFKA_LISTENER_NAME_INTERNAL_OAUTHBEARER_SASL_OAUTHBEARER_JWKS_ENDPOINT_URL: ${KC_URL}/realms/kafka/protocol/openid-connect/certs
    KAFKA_LISTENER_NAME_INTERNAL_OAUTHBEARER_SASL_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${KC_URL}/realms/kafka/protocol/openid-connect/token
    KAFKA_LISTENER_NAME_INTERNAL_OAUTHBEARER_SASL_OAUTHBEARER_EXPECTED_ISSUER: ${KC_URL}/realms/kafka
    KAFKA_LISTENER_NAME_INTERNAL_OAUTHBEARER_SASL_OAUTHBEARER_EXPECTED_AUDIENCE: account

    # OAuth2 JWKS Endpoint 配置 ( External 监听器 )
    # JAAS 配置的 clientId 和 clientSecret 用于验证 token 时候从 keycloak 获取公钥时的认证
    #
    # 验证客户端了连接的完整流程：
    # 1. Kafka UI 启动
    #   - 使用 UI_CLIENT_ID + UI_CLIENT_SECRET 向 Keycloak 请求 Access Token ( JWT )
    #
    # 2. Kafka UI 连接 Broker ( EXTERNAL:9092 )
    #   - 发送 Access Token 等待验证
    #
    # 3. Broker 收到连接请求
    #   - 提取客户端的 Access Token ( 需要验证这个 Token 的真实性 )
    #   - 使用 BROKER_CLIENT_ID + BROKER_CLIENT_SECRET 从 Keycloak 获取 JWKS 公钥
    #   - 验证 Access Token 签名 & issuer & audience & 过期时间
    #   - 验证通过，允许连接
    #
    # 4. 后续通信
    #   - 客户端继续使用同一个 Access Token
    #   - Broker 缓存 JWKS 公钥，快速验证
    KAFKA_LISTENER_NAME_EXTERNAL_OAUTHBEARER_SASL_JAAS_CONFIG: >-
      org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required
      clientId="${BROKER_CLIENT_ID}"
      clientSecret="${BROKER_CLIENT_SECRET}";
    KAFKA_LISTENER_NAME_EXTERNAL_OAUTHBEARER_SASL_OAUTHBEARER_JWKS_ENDPOINT_URL: ${KC_URL}/realms/kafka/protocol/openid-connect/certs
    KAFKA_LISTENER_NAME_EXTERNAL_OAUTHBEARER_SASL_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${KC_URL}/realms/kafka/protocol/openid-connect/token
    KAFKA_LISTENER_NAME_EXTERNAL_OAUTHBEARER_SASL_OAUTHBEARER_EXPECTED_ISSUER: ${KC_URL}/realms/kafka
    KAFKA_LISTENER_NAME_EXTERNAL_OAUTHBEARER_SASL_OAUTHBEARER_EXPECTED_AUDIENCE: account

    # SSL 配置
    KAFKA_SSL_KEY_PASSWORD: ${KAFKA_KEY_PASSWORD}
    KAFKA_SSL_KEYSTORE_LOCATION: /etc/kafka/certs/kafka.server.keystore.jks
    KAFKA_SSL_KEYSTORE_PASSWORD: ${KAFKA_KEY_PASSWORD}
    KAFKA_SSL_TRUSTSTORE_LOCATION: /etc/kafka/certs/kafka.server.truststore.jks
    KAFKA_SSL_TRUSTSTORE_PASSWORD: ${KAFKA_KEY_PASSWORD}

    # 集群副本配置
    KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 3
    KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 3
    KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 2
    KAFKA_DEFAULT_REPLICATION_FACTOR: 3
    KAFKA_MIN_INSYNC_REPLICAS: 2

    # 日志目录
    KAFKA_LOG_DIRS: /var/lib/kafka/data
  volumes:
    - ./certs:/etc/kafka/certs:ro

networks:
  jrmarcco_net:
    external: true

services:
  # OAuth2 授权服务器 ( Keycloak )
  keycloak:
    image: quay.io/keycloak/keycloak:latest
    hostname: keycloak
    container_name: keycloak
    restart: unless-stopped
    ports:
      - "18080:8080"
    environment:
      KC_BOOTSTRAP_ADMIN_USERNAME: ${BOOTSTRAP_ADMIN_USERNAME:-admin}
      KC_BOOTSTRAP_ADMIN_PASSWORD: ${BOOTSTRAP_ADMIN_PASSWORD:-admin}

      KC_HOSTNAME_STRICT: false
      KC_HTTP_ENABLED: true
      KC_HEALTH_ENABLED: true
    command:
      - start
    healthcheck:
      test: ["CMD-SHELL", "exec 3<>/dev/tcp/localhost/9000 && echo -e 'GET /health/ready HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n' >&3 && cat <&3 | grep -q '\"status\": \"UP\"'"]
      interval: 10s
      timeout: 5s
      retries: 30
    volumes:
      - ./keycloak-data:/opt/keycloak/data
    networks:
      - jrmarcco_net

  kafka-1:
    <<: *kafka-common
    hostname: kafka-1
    container_name: kafka-1
    ports:
      - "19092:9092"
    environment:
      <<: *kafka-common-env
      # 节点特定配置
      KAFKA_NODE_ID: 1
      KAFKA_LISTENERS: CONTROLLER://kafka-1:9094,INTERNAL://kafka-1:9093,EXTERNAL://0.0.0.0:9092
      KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka-1:9093,EXTERNAL://${KAFKA_EXTERNAL_IP}:19092
    volumes:
      - ./certs:/etc/kafka/certs:ro
      - ./kafka-1-data:/var/lib/kafka/data
    depends_on:
      keycloak:
        condition: service_healthy

  kafka-2:
    <<: *kafka-common
    hostname: kafka-2
    container_name: kafka-2
    ports:
      - "29092:9092"
    environment:
      <<: *kafka-common-env
      # 节点特定配置
      KAFKA_NODE_ID: 2
      KAFKA_LISTENERS: CONTROLLER://kafka-2:9094,INTERNAL://kafka-2:9093,EXTERNAL://0.0.0.0:9092
      KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka-2:9093,EXTERNAL://${KAFKA_EXTERNAL_IP}:29092
    volumes:
      - ./certs:/etc/kafka/certs:ro
      - ./kafka-2-data:/var/lib/kafka/data
    depends_on:
      keycloak:
        condition: service_healthy

  kafka-3:
    <<: *kafka-common
    hostname: kafka-3
    container_name: kafka-3
    ports:
      - "39092:9092"
    environment:
      <<: *kafka-common-env
      # 节点特定配置
      KAFKA_NODE_ID: 3
      KAFKA_LISTENERS: CONTROLLER://kafka-3:9094,INTERNAL://kafka-3:9093,EXTERNAL://0.0.0.0:9092
      KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka-3:9093,EXTERNAL://${KAFKA_EXTERNAL_IP}:39092
    volumes:
      - ./certs:/etc/kafka/certs:ro
      - ./kafka-3-data:/var/lib/kafka/data
    depends_on:
      keycloak:
        condition: service_healthy

  # Kafka UI - Web 管理界面
  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    hostname: kafka-ui
    container_name: kafka-ui
    restart: unless-stopped
    ports:
      - "18081:8080"
    environment:
      DYNAMIC_CONFIG_ENABLED: true
      KAFKA_CLUSTERS_0_NAME: kafka-cluster
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka-1:9092,kafka-2:9092,kafka-3:9092

      # OAuth2 配置
      KAFKA_CLUSTERS_0_PROPERTIES_SECURITY_PROTOCOL: SASL_SSL
      KAFKA_CLUSTERS_0_PROPERTIES_SASL_MECHANISM: OAUTHBEARER
      KAFKA_CLUSTERS_0_PROPERTIES_SASL_JAAS_CONFIG: >-
        org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required
        clientId="${UI_CLIENT_ID}"
        clientSecret="${UI_CLIENT_SECRET}";
      KAFKA_CLUSTERS_0_PROPERTIES_SASL_LOGIN_CALLBACK_HANDLER_CLASS: org.apache.kafka.common.security.oauthbearer.secured.OAuthBearerLoginCallbackHandler
      KAFKA_CLUSTERS_0_PROPERTIES_SASL_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${KC_URL}/realms/kafka/protocol/openid-connect/token

      # SSL 配置
      KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_LOCATION: /etc/kafka/certs/kafka.client.truststore.jks
      KAFKA_CLUSTERS_0_PROPERTIES_SSL_TRUSTSTORE_PASSWORD: ${KAFKA_KEY_PASSWORD}
      KAFKA_CLUSTERS_0_PROPERTIES_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM: ""

      # JVM 配置 ( 允许访问 Keycloak URL )
      JAVA_OPTS: -Dorg.apache.kafka.sasl.oauthbearer.allowed.urls=${KC_URL}/realms/kafka/protocol/openid-connect/certs,${KC_URL}/realms/kafka/protocol/openid-connect/token
    volumes:
      - ./certs:/etc/kafka/certs:ro
    networks:
      - jrmarcco_net
    depends_on:
      kafka-1:
        condition: service_healthy
      kafka-2:
        condition: service_healthy
      kafka-3:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
